import {Directive, Inject, Input, OnInit, TemplateRef, ViewContainerRef,} from '@angular/core';

import {IntentEventPublisherService} from '../services/intent-event-publisher.service';
import {ComponentLocation, IntentInfo} from '../model/intent-event.interface';
import {DOCUMENT} from "@angular/common";
import {AnimationBuilder, AnimationPlayer,} from '@angular/animations';
import {XpAnimations} from "./animations";

//https://stackblitz.com/edit/angular-animation-directive-ad?file=src%2Fapp%2Fdirectives%2Fanimation.directive.ts
//https://codepen.io/MarioDesigns/pen/woJgeo
@Directive({
  selector: '[intentSub]',
})
export class IntentSubDirective implements OnInit {
  player: AnimationPlayer | undefined;
  private eleAnimationIn = 'fade_in';
  private eleAnimationOut = 'rotate_animation';
  private viewInitialized = false;

  @Input() intentSub: string | undefined;

  constructor(
    private intentPublisher: IntentEventPublisherService,
    private template: TemplateRef<any>,
    private container: ViewContainerRef,
    @Inject(DOCUMENT) private document: Document,
    private builder: AnimationBuilder,
  ) {
    this.container.createEmbeddedView(this.template);
    intentPublisher.event$.subscribe((next) => this.onIntentUpdate(next));
  }

  ngOnInit(): void {
  }

  onIntentUpdate(next: IntentInfo): void {
    let matCardElem: Element = this.template.elementRef.nativeElement.previousElementSibling;
    const rect = this.getBoundingClientRect(matCardElem);

    const componentLocationOnX = this.getComponentRelativeLocation(next?.mouseInfo.posX, next.scrollInfo.scrollX, rect.right, rect.left);
    const componentLocationOnY = this.getComponentRelativeLocation(next?.mouseInfo.posY, next.scrollInfo.scrollY, rect.bottom, rect.top);
    const location: ComponentLocation = this.getLocation(componentLocationOnX, componentLocationOnY);
    const alignmentX: number = this.getAlignmentX(rect, next);

    this.displayBoundingClientRect(matCardElem, rect, location, alignmentX);

    if (next.direction === location.valueOf()) {
      // math should be down to confirm line generated by gesture overlaps with component
      this.inFieldOfView(matCardElem);
    } else {
      this.outFieldOfView(matCardElem);
    }
  }

  private getLocation(componentLocationOnX: number, componentLocationOnY: number) {
    if (componentLocationOnY > 0) {
      if (componentLocationOnX == 0) {
        return ComponentLocation.BELOW
      } else {
        return componentLocationOnX > 0 ? ComponentLocation.BELOW_RIGHT : ComponentLocation.BELOW_LEFT;
      }
    }
    if (componentLocationOnY < 0) {
      if (componentLocationOnX == 0) {
        return ComponentLocation.ABOVE
      } else {
        return componentLocationOnX > 0 ? ComponentLocation.ABOVE_RIGHT : ComponentLocation.ABOVE_LEFT;
      }
    } else {
      if (componentLocationOnX == 0) {
        return ComponentLocation.INSIDE;
      } else {
        return componentLocationOnX > 0 ? ComponentLocation.RIGHT : ComponentLocation.LEFT;
      }
    }
  }

  private getComponentRelativeLocation(mousePosition: number, scrollDelta: number, uCord: number, lCord: number): number {
    const mousePos = mousePosition - scrollDelta;

    if (mousePos > uCord) {
      if (mousePos > lCord) {
        return -1;
      }
      return 0;
    } else {
      if (mousePos < lCord) {
        return 1;
      } else {
        return 0;
      }
    }
  }

  getBoundingClientRect(matCardElem: Element): DOMRect {
    const rect = (matCardElem as HTMLElement).getBoundingClientRect();
    return rect;
  }

  displayBoundingClientRect(matCardElem: Element, rect: DOMRect, location: ComponentLocation, alignmentX: number) {
    let contentElem = matCardElem.firstElementChild;
    (contentElem as HTMLElement).innerHTML = '';
    for (let key in rect) {
      // @ts-ignore
      if ('function' !== typeof rect[key]) {
        let para = document.createElement('p');
        // @ts-ignore
        para.textContent = `${key} : ${rect[key]}`;
        (contentElem as HTMLElement).appendChild(para);
      }
    }
    let para = document.createElement('p');
    para.textContent = `location : ${location}`;
    (contentElem as HTMLElement).appendChild(para);

    let para2 = document.createElement('p');
    para2.textContent = `alignmentX : ${alignmentX}`;
    (contentElem as HTMLElement).appendChild(para2);

  }

  inFieldOfView(el: Element): void {
    if (this.eleAnimationIn && this.viewInitialized == false) {
      if (this.player) {
        this.player.destroy();
      }
      if (XpAnimations[this.eleAnimationIn]) {
        const metadata = XpAnimations[this.eleAnimationIn];
        const factory = this.builder.build(metadata);
        const player = factory.create(el);
        player.play();
      } else {
        throw new Error(`Invalid animation  ${this.eleAnimationIn}`);
      }
    }
    this.viewInitialized = true;
  }

  outFieldOfView(el: Element): void {
    if (this.eleAnimationOut && this.viewInitialized == true) {
      if (this.player) {
        this.player.destroy();
      }
      if (XpAnimations[this.eleAnimationOut]) {
        const metadata = XpAnimations[this.eleAnimationOut];
        const factory = this.builder.build(metadata);
        const player = factory.create(el);
        player.play();
      } else {
        throw new Error(`Invalid animation  ${this.eleAnimationOut}`);
      }
      this.viewInitialized = false;
    }
  }

  private getAlignmentX( rect: DOMRect, next: IntentInfo) {
    const midScreenX = next.windowInfo.width/2;
    console.log(midScreenX);
    return (midScreenX > rect.left) ? -1 : (midScreenX< rect.right ? 1: 0);
  }

}
